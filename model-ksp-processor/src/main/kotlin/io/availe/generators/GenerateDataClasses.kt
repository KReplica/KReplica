package io.availe.generators

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import io.availe.SCHEMA_SUFFIX
import io.availe.SERIALIZABLE_QUALIFIED_NAME
import io.availe.builders.asClassName
import io.availe.builders.buildAnnotationSpec
import io.availe.builders.buildDataTransferObjectClass
import io.availe.builders.overwriteFile
import io.availe.models.*
import io.availe.validation.fieldsFor

private const val TOP_LEVEL_CLASS_KDOC: String =
    "A sealed interface hierarchy representing all versions of the %L data model."
private const val FILE_HEADER_COMMENT: String = "Generated by KReplica. Do not edit."
private const val INTERNAL_SCHEMAS_FILE_NAME = "_InternalKReplicaSchemas"

private fun generateVersionBoxKdoc(versionName: String, schemaVersion: Int): String {
    val title = "Version $schemaVersion ($versionName)"
    val line = "--------------------------"
    val content = "| $title |"
    return """
        $line
        $content
        $line
    """.trimIndent()
}

internal fun generatePublicSchemas(
    primaryModels: List<Model>,
    allModels: List<Model>,
    codeGenerator: CodeGenerator,
    dependencies: Dependencies
) {
    val modelsByBaseName = allModels.groupBy { it.isVersionOf ?: it.name }
    val primaryModelsByBaseName = primaryModels.groupBy { it.isVersionOf ?: it.name }

    primaryModelsByBaseName.forEach { (baseName, versions) ->
        generatePublicSchemaFile(baseName, versions, modelsByBaseName, codeGenerator, dependencies)
    }
}

internal fun generateInternalSchemasFile(
    primaryModels: List<Model>,
    allModels: List<Model>,
    codeGenerator: CodeGenerator,
    dependencies: Dependencies
) {
    if (primaryModels.isEmpty()) return

    val modelsByBaseName = allModels.groupBy { it.isVersionOf ?: it.name }
    val primaryModelsByBaseName = primaryModels.groupBy { it.isVersionOf ?: it.name }
    val representativeModel = primaryModels.first()
    val packageName = representativeModel.packageName

    val fileSpec = FileSpec.builder(packageName, INTERNAL_SCHEMAS_FILE_NAME).apply {
        addFileComment(FILE_HEADER_COMMENT)
        addOptInMarkersForModels(primaryModels, modelsByBaseName)

        primaryModelsByBaseName.forEach { (baseName, versions) ->
            val model = versions.first()
            val schemaTypeSpec = if (model.isVersionOf != null) {
                buildVersionedSchema(baseName, versions, modelsByBaseName, KModifier.INTERNAL)
            } else {
                buildUnversionedSchema(baseName, model, modelsByBaseName, KModifier.INTERNAL)
            }
            addType(schemaTypeSpec)
        }
    }.build()

    overwriteFile(fileSpec, codeGenerator, dependencies)
}

private fun generatePublicSchemaFile(
    baseName: String,
    versions: List<Model>,
    modelsByBaseName: Map<String, List<Model>>,
    codeGenerator: CodeGenerator,
    dependencies: Dependencies
) {
    val representativeModel = versions.first()
    val schemaFileName = (representativeModel.isVersionOf ?: representativeModel.name) + SCHEMA_SUFFIX

    val fileSpec = FileSpec.builder(representativeModel.packageName, schemaFileName).apply {
        addFileComment(FILE_HEADER_COMMENT)
        addOptInMarkersForModels(versions, modelsByBaseName)
        if (representativeModel.isVersionOf != null) {
            val schemaSpec = buildVersionedSchema(baseName, versions, modelsByBaseName, KModifier.PUBLIC)
            addType(schemaSpec)
        } else {
            val schemaSpec = buildUnversionedSchema(baseName, versions.first(), modelsByBaseName, KModifier.PUBLIC)
            addType(schemaSpec)
        }
    }.build()

    overwriteFile(fileSpec, codeGenerator, dependencies)
}

private fun buildVersionedSchema(
    baseName: String,
    versions: List<Model>,
    modelsByBaseName: Map<String, List<Model>>,
    visibility: KModifier
): TypeSpec {
    val representativeModel = versions.first()
    val schemaFileName = (representativeModel.isVersionOf ?: representativeModel.name) + SCHEMA_SUFFIX
    val isGloballySerializable =
        representativeModel.annotationConfigs.any { it.annotation.qualifiedName == SERIALIZABLE_QUALIFIED_NAME }
    val packageName = representativeModel.packageName
    val supertypesFqns = representativeModel.supertypes

    return TypeSpec.interfaceBuilder(schemaFileName).apply {
        addModifiers(KModifier.SEALED, visibility)
        supertypesFqns.forEach {
            addSuperinterface(it.fqn.asClassName()) // Fixed line
        }

        if (isGloballySerializable) {
            addAnnotation(ClassName("kotlinx.serialization", "Serializable"))
        }
        addKdoc(TOP_LEVEL_CLASS_KDOC, baseName)

        val allVariants = versions.flatMap { it.dtoVariants }.toSet()
        allVariants.forEach { variant ->
            val interfaceName = "${variant.suffix}Variant"
            val variantInterfaceBuilder = TypeSpec.interfaceBuilder(interfaceName).apply {
                addModifiers(KModifier.SEALED)
                addSuperinterface(ClassName(packageName, schemaFileName))
            }.build()
            addType(variantInterfaceBuilder)
        }

        versions.forEach { version ->
            val dtos = generateDataTransferObjects(version, modelsByBaseName)
            val versionClass = TypeSpec.interfaceBuilder(version.name).apply {
                addModifiers(KModifier.SEALED)
                addSuperinterface(ClassName(packageName, schemaFileName))
                version.annotations.forEach { addAnnotation(buildAnnotationSpec(it)) }
                if (version.annotationConfigs.any { it.annotation.qualifiedName == SERIALIZABLE_QUALIFIED_NAME }) {
                    addAnnotation(ClassName("kotlinx.serialization", "Serializable"))
                }
                addKdoc(generateVersionBoxKdoc(version.name, version.schemaVersion!!))
                addTypes(dtos)
            }.build()
            addType(versionClass)
        }
    }.build()
}

private fun buildUnversionedSchema(
    baseName: String,
    model: Model,
    modelsByBaseName: Map<String, List<Model>>,
    visibility: KModifier
): TypeSpec {
    val schemaFileName = model.name + SCHEMA_SUFFIX
    val schemaInterfaceName = ClassName(model.packageName, schemaFileName)
    val isGloballySerializable =
        model.annotationConfigs.any { it.annotation.qualifiedName == SERIALIZABLE_QUALIFIED_NAME }
    val supertypesFqns = model.supertypes

    return TypeSpec.interfaceBuilder(schemaInterfaceName).apply {
        addModifiers(KModifier.SEALED, visibility)
        supertypesFqns.forEach {
            addSuperinterface(it.fqn.asClassName()) // Fixed line
        }

        addKdoc("A sealed hierarchy representing all variants of the %L data model.", baseName)
        model.annotations.forEach { addAnnotation(buildAnnotationSpec(it)) }
        if (isGloballySerializable) {
            addAnnotation(ClassName("kotlinx.serialization", "Serializable"))
        }

        val dtos = generateDataTransferObjects(model, modelsByBaseName)
        dtos.forEach { dtoSpec ->
            val dtoBuilder = dtoSpec.toBuilder().apply {
                addSuperinterface(schemaInterfaceName)
                DtoVariant.entries.find { it.suffix == dtoSpec.name }?.let { variant ->
                    val globalVariantInterfaceBase = when (variant) {
                        DtoVariant.DATA -> KReplicaDataVariant::class.asClassName()
                        DtoVariant.CREATE -> KReplicaCreateVariant::class.asClassName()
                        DtoVariant.PATCH -> KReplicaPatchVariant::class.asClassName()
                    }
                    val parameterizedGlobalVariant = globalVariantInterfaceBase.parameterizedBy(schemaInterfaceName)
                    addSuperinterface(parameterizedGlobalVariant)
                }
            }.build()
            addType(dtoBuilder)
        }
    }.build()
}

private fun generateDataTransferObjects(model: Model, modelsByBaseName: Map<String, List<Model>>): List<TypeSpec> {
    return model.dtoVariants.mapNotNull { variant ->
        val fields = model.fieldsFor(variant)
        if (fields.isNotEmpty() || model.properties.any { it is FlattenedProperty && variant in it.dtoVariants }) {
            buildDataTransferObjectClass(model, model.properties, variant, modelsByBaseName)
        } else null
    }
}

private fun FileSpec.Builder.addOptInMarkersForModels(
    models: List<Model>,
    modelsByBaseName: Map<String, List<Model>>
): FileSpec.Builder {

    val markerCache = mutableMapOf<Model, Set<String>>()

    fun collectMarkers(model: Model): Set<String> {
        return markerCache.getOrPut(model) {
            val ownMarkers = model.optInMarkers.toSet()
            val flattenedMarkers = model.properties
                .filterIsInstance<FlattenedProperty>()
                .flatMap { flatProp ->
                    val targetModel = modelsByBaseName[flatProp.foreignBaseModelName]
                        ?.find { it.name == flatProp.foreignVersionName }
                    if (targetModel != null) {
                        collectMarkers(targetModel)
                    } else {
                        emptySet()
                    }
                }
                .toSet()
            ownMarkers + flattenedMarkers
        }
    }

    val distinctMarkers = models.flatMap { collectMarkers(it) }.distinct()

    if (distinctMarkers.isNotEmpty()) {
        val format = distinctMarkers.joinToString(", ") { "%T::class" }
        val args = distinctMarkers.map { fq ->
            val pkg = fq.substringBeforeLast('.')
            val cls = fq.substringAfterLast('.')
            ClassName(pkg, cls)
        }.toTypedArray()
        addAnnotation(
            AnnotationSpec.builder(ClassName("kotlin", "OptIn"))
                .addMember(format, *args)
                .build()
        )
    }
    return this
}