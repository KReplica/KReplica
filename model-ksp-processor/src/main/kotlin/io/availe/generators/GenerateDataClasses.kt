package io.availe.generators

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import io.availe.SCHEMA_SUFFIX
import io.availe.SERIALIZABLE_QUALIFIED_NAME
import io.availe.builders.buildAnnotationSpec
import io.availe.builders.buildDataTransferObjectClass
import io.availe.builders.overwriteFile
import io.availe.models.*
import io.availe.validation.fieldsFor
import org.slf4j.LoggerFactory

private val logger = LoggerFactory.getLogger("io.availe.generators")

private const val TOP_LEVEL_CLASS_KDOC: String =
    "A sealed interface hierarchy representing all versions of the %L data model."
private const val FILE_HEADER_COMMENT: String = "Generated by KReplica. Do not edit."

private fun generateVersionBoxKdoc(versionName: String, schemaVersion: Int): String {
    val title = "Version $schemaVersion ($versionName)"
    val line = "--------------------------"
    val content = "|   $title   |"
    return """
        $line
        $content
        $line
    """.trimIndent()
}

internal fun generateDataClasses(
    primaryModels: List<Model>,
    allModels: List<Model>,
    codeGenerator: CodeGenerator,
    dependencies: Dependencies
) {
    val modelsByBaseName = allModels.groupBy { it.isVersionOf ?: it.name }
    val primaryModelsByBaseName = primaryModels.groupBy { it.isVersionOf ?: it.name }
    primaryModelsByBaseName.forEach { (baseName, versions) ->
        generateSchemaFile(baseName, versions, modelsByBaseName, codeGenerator, dependencies)
    }
}

private fun generateSchemaFile(
    baseName: String,
    versions: List<Model>,
    modelsByBaseName: Map<String, List<Model>>,
    codeGenerator: CodeGenerator,
    dependencies: Dependencies
) {
    val representativeModel = versions.first()
    val schemaFileName = (representativeModel.isVersionOf ?: representativeModel.name) + SCHEMA_SUFFIX

    val fileSpec = FileSpec.builder(representativeModel.packageName, schemaFileName).apply {
        addFileComment(FILE_HEADER_COMMENT)
        addOptInMarkersForModels(versions)
        if (representativeModel.isVersionOf != null) {
            generateVersionedSchema(baseName, versions, modelsByBaseName)
        } else {
            generateUnversionedSchema(baseName, versions.first(), modelsByBaseName)
        }
    }.build()

    overwriteFile(fileSpec, codeGenerator, dependencies)
}

private fun FileSpec.Builder.generateVersionedSchema(
    baseName: String,
    versions: List<Model>,
    modelsByBaseName: Map<String, List<Model>>
) {
    val representativeModel = versions.first()
    val schemaFileName = (representativeModel.isVersionOf ?: representativeModel.name) + SCHEMA_SUFFIX
    val isGloballySerializable =
        representativeModel.annotationConfigs.any { it.annotation.qualifiedName == SERIALIZABLE_QUALIFIED_NAME }

    val topLevelClassBuilder = TypeSpec.interfaceBuilder(schemaFileName).apply {
        addModifiers(KModifier.SEALED)
        if (isGloballySerializable) {
            addAnnotation(ClassName("kotlinx.serialization", "Serializable"))
        }
        addKdoc(TOP_LEVEL_CLASS_KDOC, baseName)

        val allVariants = versions.flatMap { it.dtoVariants }.toSet()
        allVariants.forEach { variant ->
            val interfaceName = "${variant.suffix}Variant"
            val variantInterfaceBuilder = TypeSpec.interfaceBuilder(interfaceName).apply {
                addModifiers(KModifier.SEALED)
                addSuperinterface(ClassName(representativeModel.packageName, schemaFileName))
            }.build()
            addType(variantInterfaceBuilder)
        }

        versions.forEach { version ->
            val dtos = generateDataTransferObjects(version, modelsByBaseName)
            val versionClass = TypeSpec.interfaceBuilder(version.name).apply {
                addModifiers(KModifier.SEALED)
                addSuperinterface(ClassName(version.packageName, schemaFileName))
                version.annotations.forEach { addAnnotation(buildAnnotationSpec(it)) }
                if (version.annotationConfigs.any { it.annotation.qualifiedName == SERIALIZABLE_QUALIFIED_NAME }) {
                    addAnnotation(ClassName("kotlinx.serialization", "Serializable"))
                }
                addKdoc(generateVersionBoxKdoc(version.name, version.schemaVersion!!))
                addTypes(dtos)
            }.build()
            addType(versionClass)
        }
    }.build()
    addType(topLevelClassBuilder)
}

private fun FileSpec.Builder.generateUnversionedSchema(
    baseName: String,
    model: Model,
    modelsByBaseName: Map<String, List<Model>>
) {
    val schemaFileName = model.name + SCHEMA_SUFFIX
    val schemaInterfaceName = ClassName(model.packageName, schemaFileName)
    val isGloballySerializable =
        model.annotationConfigs.any { it.annotation.qualifiedName == SERIALIZABLE_QUALIFIED_NAME }

    val schemaBuilder = TypeSpec.interfaceBuilder(schemaInterfaceName).apply {
        addModifiers(KModifier.SEALED)
        addKdoc("A sealed hierarchy representing all variants of the %L data model.", baseName)
        model.annotations.forEach { addAnnotation(buildAnnotationSpec(it)) }
        if (isGloballySerializable) {
            addAnnotation(ClassName("kotlinx.serialization", "Serializable"))
        }

        val dtos = generateDataTransferObjects(model, modelsByBaseName)
        dtos.forEach { dtoSpec ->
            val dtoBuilder = dtoSpec.toBuilder().apply {
                addSuperinterface(schemaInterfaceName)
                DtoVariant.entries.find { it.suffix == dtoSpec.name }?.let { variant ->
                    val globalVariantInterfaceBase = when (variant) {
                        DtoVariant.DATA -> KReplicaDataVariant::class.asClassName()
                        DtoVariant.CREATE -> KReplicaCreateVariant::class.asClassName()
                        DtoVariant.PATCH -> KReplicaPatchVariant::class.asClassName()
                    }
                    val parameterizedGlobalVariant = globalVariantInterfaceBase.parameterizedBy(schemaInterfaceName)
                    addSuperinterface(parameterizedGlobalVariant)
                }
            }.build()
            addType(dtoBuilder)
        }
    }.build()
    addType(schemaBuilder)
}

private fun generateDataTransferObjects(model: Model, modelsByBaseName: Map<String, List<Model>>): List<TypeSpec> {
    return model.dtoVariants.mapNotNull { variant ->
        val fields = model.fieldsFor(variant)
        if (fields.isNotEmpty()) {
            buildDataTransferObjectClass(model, fields, variant, modelsByBaseName)
        } else null
    }
}

private fun FileSpec.Builder.addOptInMarkersForModels(models: List<Model>): FileSpec.Builder {
    val distinctMarkers = models.flatMap { it.optInMarkers }.distinct()
    if (distinctMarkers.isNotEmpty()) {
        val format = distinctMarkers.joinToString(", ") { "%T::class" }
        val args = distinctMarkers.map { fq ->
            val pkg = fq.substringBeforeLast('.')
            val cls = fq.substringAfterLast('.')
            ClassName(pkg, cls)
        }.toTypedArray()
        addAnnotation(
            AnnotationSpec.builder(ClassName("kotlin", "OptIn"))
                .addMember(format, *args)
                .build()
        )
    }
    return this
}